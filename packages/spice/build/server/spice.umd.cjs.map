{"version":3,"file":"spice.umd.cjs","sources":["../../src/components/FormField/components/item/Input.tsx","../../src/components/FormField/components/item/Select.tsx","../../src/components/FormField/components/FieldLayout.tsx","../../src/components/FormField/components/item/Textarea.tsx","../../src/components/FormField/index.tsx","../../src/components/CustomBreakLineParser/index.tsx","../../src/components/SplitText/index.tsx","../../src/components/Video/index.tsx","../../src/utils/paging.ts"],"sourcesContent":["import { FormProps } from \"../..\";\n\nexport const Input = ({ formProps }: { formProps: FormProps }) => {\n   const { style, ...rest } = formProps;\n   return (\n      <input\n         {...rest}\n         style={{\n            overflow: \"hidden\",\n            ...style,\n         }}\n      />\n   );\n};\n","import { SelectProps } from \"../..\";\n\nexport const Select = ({ formProps }: { formProps: SelectProps }) => {\n   const { isSelect, style, ...rest } = formProps;\n   if (!isSelect) {\n      return;\n   }\n\n   const DefaultValue = () => {\n      const defaultValue = isSelect.defaultValue;\n      if (!defaultValue) {\n         return null;\n      }\n      return <option hidden>{defaultValue}</option>;\n   };\n\n   const getSelectedIndex = () => {\n      const i = isSelect.defaultSelectedIndex;\n      if (!i) {\n         return undefined;\n      }\n      return isSelect.options[i];\n   };\n\n   return (\n      <select\n         {...rest}\n         style={{\n            overflow: \"hidden\",\n            fontSize: \"16px\",\n            ...(style || {}),\n         }}\n         defaultValue={getSelectedIndex()}>\n         <DefaultValue />\n         {isSelect.options.map((option: any) => {\n            return (\n               <option key={option} value={option}>\n                  {option}\n               </option>\n            );\n         })}\n      </select>\n   );\n};\n","import { FormProps } from \"..\";\n\nexport type FormItem = React.FC<{\n   formProps: FormProps;\n}>;\n\ntype FieldLayoutProps = {\n   layoutType: \"block\" | \"flex\" | \"radio-check\";\n   formPropsArr: FormProps[];\n   label?: string | React.ReactNode;\n   FormItem: FormItem;\n   errors?: React.ReactNode[] | React.ReactNode;\n};\n\nconst RADIO_CHECKBOX_STYLE = {\n   position: \"absolute\",\n   whiteSpace: \"nowrap\",\n   width: \"1px\",\n   height: \"1px\",\n   overflow: \"hidden\",\n   border: \"0\",\n   padding: 0,\n   clip: \"rect(0 0 0 0)\",\n   clipPath: \"inset(50%)\",\n   zIndex: \"-99999\",\n} as React.CSSProperties;\n\nexport const FieldLayout = ({\n   layoutType,\n   formPropsArr,\n   label,\n   FormItem,\n   errors,\n}: FieldLayoutProps) => {\n   const ErrorMessage = ({ index }: { index: number }) => {\n      if (!errors) {\n         return null;\n      }\n      if (Array.isArray(errors)) {\n         return errors[index];\n      }\n      return errors;\n   };\n\n   if (layoutType === \"block\") {\n      return (\n         <>\n            {label && <label htmlFor={formPropsArr[0].id}>{label}</label>}\n            <FormItem formProps={formPropsArr[0]} />\n            <ErrorMessage index={0} />\n         </>\n      );\n   }\n\n   if (layoutType === \"flex\") {\n      return (\n         <>\n            {label && <label htmlFor={formPropsArr[0].id}>{label}</label>}\n            <ul>\n               <li>\n                  <FormItem formProps={formPropsArr[0]} />\n                  <ErrorMessage index={0} />\n               </li>\n               <li>\n                  <FormItem formProps={formPropsArr[1]} />\n                  <ErrorMessage index={1} />\n               </li>\n            </ul>\n         </>\n      );\n   }\n\n   if (layoutType === \"radio-check\") {\n      const Options = formPropsArr.map(\n         ({ id, value, style, optionLabel, ...rest }) => {\n            return (\n               <li key={id}>\n                  <FormItem\n                     formProps={{\n                        id,\n                        value,\n                        style: {\n                           ...RADIO_CHECKBOX_STYLE,\n                           ...(style || {}),\n                        },\n                        ...rest,\n                     }}\n                  />\n                  <label htmlFor={id}>{optionLabel || value}</label>\n               </li>\n            );\n         }\n      );\n      return (\n         <>\n            {label && <label>{label}</label>}\n            <ul>{Options}</ul>\n            <ErrorMessage index={0} />\n         </>\n      );\n   }\n};\n","import { TextareaProps } from \"../..\";\n\nexport const Textarea = ({ formProps }: { formProps: TextareaProps }) => {\n   const { isTextarea, ...rest } = formProps;\n   if (!isTextarea) {\n      return;\n   }\n   return <textarea {...rest} {...isTextarea}></textarea>;\n};\n","import { Input } from \"./components/item/Input\";\nimport { Select } from \"./components/item/Select\";\nimport { FieldLayout } from \"./components/FieldLayout\";\nimport { Textarea } from \"./components/item/Textarea\";\n\ntype SelectOptions = {\n   defaultValue?: string;\n   defaultSelectedIndex?: number;\n   options: string[];\n};\n\nexport type SelectProps = {\n   isSelect?: SelectOptions;\n} & React.SelectHTMLAttributes<HTMLSelectElement>;\n\nexport type TextareaProps = {\n   isTextarea?: React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n} & React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n\ntype OptionLabel = {\n   optionLabel?: React.ReactNode;\n};\n\nexport type FormProps = React.InputHTMLAttributes<HTMLInputElement> &\n   SelectProps &\n   TextareaProps &\n   OptionLabel;\n\nexport type FormFieldsProps = {\n   label?: string | React.ReactNode;\n   /**  param formProps If you set two in an array, they will be arranged as flex. For select and textarea, set tag attributes to isSelect and isTextarea, respectively. */\n   formProps: FormProps[] | FormProps;\n   /** React.ReactNode[] for validation */\n   errors?: React.ReactNode[] | React.ReactNode;\n} & React.FieldsetHTMLAttributes<HTMLFieldSetElement>;\n\n/**\n *\n * ```jsx\n * <FormField\n\t\tclassName={s.field}\n\t\tlabel=\"Mail\"\n\t\tformProps={{\n\t\t\ttype: \"email\",\n\t\t\tid: \"e-mail\",\n\t\t\tplaceholder: \"t.hashimoto@funtech.inc\",\n\t\t\t...register(\"email\", {\n\t\t\t\trequired: VALIDATION.required,\n\t\t\t\tpattern: {\n\t\t\t\t\tvalue: VALIDATION.emailRegExp,\n\t\t\t\t\tmessage: VALIDATION.email,\n\t\t\t\t},\n\t\t\t}),\n\t\t}}\n\t\terrors={<Error error={errors?.email?.message || \"\"} />}\n\t/>\n```\n */\nexport const FormField = ({\n   label,\n   formProps,\n   errors,\n   ...rest\n}: FormFieldsProps) => {\n   if (errors && Array.isArray(errors) && errors.length > 2) {\n      throw new Error(\"The length of error is up to 2.\");\n   }\n\n   const formPropsArr = Array.isArray(formProps) ? formProps : [formProps];\n\n   const { type, isSelect, isTextarea } = formPropsArr[0];\n   const propsLength = formPropsArr.length;\n\n   if (!(type === \"radio\" || type === \"checkbox\") && propsLength > 2) {\n      throw new Error(\"The length of formProps is up to 2.\");\n   }\n\n   const layoutType = [\"radio\", \"checkbox\"].includes(type || \"\")\n      ? \"radio-check\"\n      : propsLength === 1\n      ? \"block\"\n      : \"flex\";\n\n   return (\n      <fieldset {...rest}>\n         <FieldLayout\n            layoutType={layoutType}\n            formPropsArr={formPropsArr}\n            label={label}\n            errors={errors}\n            FormItem={isSelect ? Select : isTextarea ? Textarea : Input}\n         />\n      </fieldset>\n   );\n};\n","import { useMemo } from \"react\";\n\ntype CustomBreakLineParserProps = {\n   children: string;\n};\n\nexport const CustomBreakLineUtils = {\n   regex: /(\\n|###br\\.[^#]+###|###br###)/,\n   isRegularBreak: (line: string) => line === \"\\n\" || line === \"###br###\",\n   isSpecificBreak: (line: string) => line.match(/###br\\.(.*?)###/),\n   getClassName: (line: string) =>\n      line.match(/(?<=###br\\.).+?(?=###)/)?.[0] || \"\",\n};\n\n/**\n * @returns {(string | JSX.Element)[]} - A React fragment containing the formatted string with line breaks represented as `<br>` elements.\n */\nconst useParsedBreakLine = (string: string): (string | JSX.Element)[] =>\n   useMemo(\n      () =>\n         string.split(CustomBreakLineUtils.regex).map((line, index) => {\n            // \\n or ###br### is a regular line break\n            if (CustomBreakLineUtils.isRegularBreak(line)) {\n               return <br key={index} />;\n            }\n            // ###br.className### is a line break with a specified class name\n            if (CustomBreakLineUtils.isSpecificBreak(line)) {\n               return (\n                  <br\n                     className={CustomBreakLineUtils.getClassName(line)}\n                     key={index}\n                  />\n               );\n            }\n            // Regular text\n            return line;\n         }),\n      [string]\n   );\n\n/**\n * Converts specific markers in a string into HTML line breaks for React components.\n * @param {string} children - The input string to be parsed and formatted. Use `\\n` or `###br###` for regular line breaks, and `###br.className###` for a line break with a specific class.\n * @returns {React.ReactElement} - The formatted string\n */\nconst CustomBreakLineParser = ({\n   children,\n}: CustomBreakLineParserProps): React.ReactElement => {\n   const parsedText = useParsedBreakLine(children);\n   return <>{parsedText}</>;\n};\n\nexport { useParsedBreakLine, CustomBreakLineParser };\n","import { useMemo } from \"react\";\nimport { CustomBreakLineUtils } from \"../CustomBreakLineParser\";\n\ntype SpanOmittedChildren = Omit<\n   React.HTMLAttributes<HTMLSpanElement>,\n   \"children\"\n>;\n\nexport type SplitTextProps = {\n   /** Split by character or by word . For `words`, split by whitespace. */\n   type?: \"chars\" | \"words\";\n   /** It is possible to set exceptional attributes for certain characters only */\n   exception?: {\n      selector: string;\n      attributes?: SpanOmittedChildren;\n   }[];\n   containerProps?: SpanOmittedChildren;\n   children: string;\n} & SpanOmittedChildren;\n\nconst SplitContainer = ({\n   containerProps,\n   ...props\n}: {\n   containerProps?: SpanOmittedChildren;\n} & React.HTMLAttributes<HTMLSpanElement>) => {\n   if (containerProps) {\n      return (\n         <span {...containerProps}>\n            <span {...props} />\n         </span>\n      );\n   }\n   return <span {...props} />;\n};\n\n/**\n * @param children - The input string to be parsed and formatted. Use `\\n` or `###br###` for regular line breaks, and `###br.className###` for a line break with a specific class.\n */\nexport const SplitText = ({\n   type = \"chars\",\n   children,\n   exception,\n   containerProps,\n   ...rest\n}: SplitTextProps) => {\n   const splitTag = type === \"chars\" ? \"\" : \" \";\n\n   const wrappedText = useMemo(\n      () =>\n         children.split(CustomBreakLineUtils.regex).flatMap((line, i) => {\n            if (CustomBreakLineUtils.isRegularBreak(line)) {\n               return [null, <br key={i} />];\n            }\n            if (CustomBreakLineUtils.isSpecificBreak(line)) {\n               return [\n                  null,\n                  <br\n                     key={i}\n                     className={CustomBreakLineUtils.getClassName(line)}\n                  />,\n               ];\n            }\n            return [\n               ...line.split(splitTag).map((char, charI) => {\n                  if (exception) {\n                     const match = exception.find(\n                        (item) => item.selector === char\n                     );\n                     if (match) {\n                        return (\n                           <SplitContainer\n                              key={`${i}-${charI}`}\n                              containerProps={containerProps}\n                              {...rest}\n                              {...match.attributes}>\n                              {char}\n                           </SplitContainer>\n                        );\n                     }\n                  }\n                  return (\n                     <SplitContainer\n                        key={`${i}-${charI}`}\n                        containerProps={containerProps}\n                        {...rest}>\n                        {char === \" \" ? \"\\u00A0\" : char}\n                     </SplitContainer>\n                  );\n               }),\n               null,\n            ];\n         }),\n      [splitTag, children, rest, exception, containerProps]\n   );\n\n   return wrappedText;\n};\n","import { VideoHTMLAttributes, forwardRef } from \"react\";\n\nexport interface VideoProps extends VideoHTMLAttributes<HTMLVideoElement> {\n   fill?: boolean;\n}\n\nexport const Video = forwardRef<HTMLVideoElement, VideoProps>((props, ref) => {\n   const { fill, style, ...rest } = props;\n   return (\n      <video\n         ref={ref}\n         style={\n            fill\n               ? {\n                    ...{\n                       position: \"absolute\",\n                       width: \"100%\",\n                       height: \"100%\",\n                       inset: 0,\n                       color: \"transparent\",\n                    },\n                    ...style,\n                 }\n               : style\n         }\n         {...rest}></video>\n   );\n});\n\nVideo.displayName = \"Video\";\n","type PagingItem<T extends string = \"...\"> = number | T;\n\nconst getRange = <T extends string>(\n   start: number,\n   end: number\n): PagingItem<T>[] => {\n   if (end < start)\n      throw Error(\n         `End number must be higher then start number: start ${start}, end ${start}`\n      );\n\n   const rangeLength = end - start + 1;\n   return Array(rangeLength)\n      .fill(0)\n      .map((_, i) => i + start);\n};\n\nconst clamp = (value: number, lower: number, upper: number) =>\n   Math.min(Math.max(value, lower), upper);\n\nexport const getPageRange = (totalCount: number, perPage: number) => {\n   return getRange(1, Math.ceil(totalCount / perPage));\n};\n\nexport const getPaginationRange = <T extends string>(\n   currentPage: number,\n   totalCount: number,\n   perPage: number,\n   size: number = 5,\n   skip: T = \"...\" as T\n): PagingItem<T>[] => {\n   totalCount = Math.ceil(totalCount / perPage);\n\n   if (totalCount < 1) {\n      console.warn(\"Page count has negative value. Returning empty array.\");\n      return [];\n   }\n\n   if (currentPage < 1) {\n      console.warn(\n         \"Current page has negative value. Current page will be set to 1\"\n      );\n      currentPage = 1;\n   }\n\n   if (currentPage > totalCount) {\n      console.warn(\n         \"Current page is higher than page count. Current page will be set to page count:\",\n         totalCount\n      );\n      currentPage = totalCount;\n   }\n\n   if (size % 2 === 0) {\n      console.warn(\"The size must be odd. The size will be increased by 1\");\n      size += 1;\n   }\n\n   if (size < 5) {\n      console.warn(\"The minimum size is 5. The size will be increased to 5\");\n      size = 5;\n   }\n\n   const offset = (size - 1) / 2;\n   const shouldAddDots = totalCount > size;\n\n   const rangeConfig = {\n      start: clamp(\n         currentPage - offset,\n         1,\n         shouldAddDots ? totalCount - size + 1 : 1\n      ),\n      end: clamp(currentPage + offset, size, totalCount),\n   };\n\n   const pages = getRange<T>(rangeConfig.start, rangeConfig.end);\n\n   if (shouldAddDots && pages[0] !== 1) {\n      pages[0] = 1;\n      pages[1] = skip;\n   }\n   if (shouldAddDots && pages[pages.length - 1] !== totalCount) {\n      pages[pages.length - 1] = totalCount;\n      pages[pages.length - 2] = skip;\n   }\n   return pages;\n};\n"],"names":["Input","formProps","style","rest","jsx","Select","isSelect","DefaultValue","defaultValue","getSelectedIndex","i","jsxs","option","RADIO_CHECKBOX_STYLE","FieldLayout","layoutType","formPropsArr","label","FormItem","errors","ErrorMessage","index","Fragment","Options","id","value","optionLabel","Textarea","isTextarea","FormField","type","propsLength","CustomBreakLineUtils","line","_a","useParsedBreakLine","string","useMemo","CustomBreakLineParser","children","parsedText","SplitContainer","containerProps","props","SplitText","exception","splitTag","char","charI","match","item","Video","forwardRef","ref","fill","getRange","start","end","rangeLength","_","clamp","lower","upper","totalCount","perPage","currentPage","size","skip","offset","shouldAddDots","rangeConfig","pages"],"mappings":"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"}