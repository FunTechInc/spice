{"version":3,"file":"spice.js","sources":["../../src/components/FormField/components/item/Input.tsx","../../src/components/FormField/components/item/Select.tsx","../../src/components/FormField/components/FieldLayout.tsx","../../src/components/FormField/components/item/Textarea.tsx","../../src/components/FormField/index.tsx","../../src/components/CustomBreakLineParser/index.tsx","../../src/components/SplitText/index.tsx","../../src/components/Video/index.tsx"],"sourcesContent":["import { FormProps } from \"../..\";\n\nexport const Input = ({ formProps }: { formProps: FormProps }) => {\n   const { style, ...rest } = formProps;\n   return (\n      <input\n         {...rest}\n         style={{\n            overflow: \"hidden\",\n            ...style,\n         }}\n      />\n   );\n};\n","import { SelectProps } from \"../..\";\n\nexport const Select = ({ formProps }: { formProps: SelectProps }) => {\n   const { isSelect, style, ...rest } = formProps;\n   if (!isSelect) {\n      return;\n   }\n\n   const DefaultValue = () => {\n      const defaultValue = isSelect.defaultValue;\n      if (!defaultValue) {\n         return null;\n      }\n      return <option hidden>{defaultValue}</option>;\n   };\n\n   const getSelectedIndex = () => {\n      const i = isSelect.defaultSelectedIndex;\n      if (!i) {\n         return undefined;\n      }\n      return isSelect.options[i];\n   };\n\n   return (\n      <select\n         {...rest}\n         style={{\n            overflow: \"hidden\",\n            fontSize: \"16px\",\n            ...(style || {}),\n         }}\n         defaultValue={getSelectedIndex()}>\n         <DefaultValue />\n         {isSelect.options.map((option: any) => {\n            return (\n               <option key={option} value={option}>\n                  {option}\n               </option>\n            );\n         })}\n      </select>\n   );\n};\n","import { FormProps } from \"..\";\n\nexport type FormItem = React.FC<{\n   formProps: FormProps;\n}>;\n\ntype FieldLayoutProps = {\n   layoutType: \"block\" | \"flex\" | \"radio-check\";\n   formPropsArr: FormProps[];\n   label?: string | React.ReactNode;\n   FormItem: FormItem;\n   errors?: React.ReactNode[] | React.ReactNode;\n};\n\nconst RADIO_CHECKBOX_STYLE = {\n   position: \"absolute\",\n   whiteSpace: \"nowrap\",\n   width: \"1px\",\n   height: \"1px\",\n   overflow: \"hidden\",\n   border: \"0\",\n   padding: 0,\n   clip: \"rect(0 0 0 0)\",\n   clipPath: \"inset(50%)\",\n   zIndex: \"-99999\",\n} as React.CSSProperties;\n\nexport const FieldLayout = ({\n   layoutType,\n   formPropsArr,\n   label,\n   FormItem,\n   errors,\n}: FieldLayoutProps) => {\n   const ErrorMessage = ({ index }: { index: number }) => {\n      if (!errors) {\n         return null;\n      }\n      if (Array.isArray(errors)) {\n         return errors[index];\n      }\n      return errors;\n   };\n\n   if (layoutType === \"block\") {\n      return (\n         <>\n            {label && <label htmlFor={formPropsArr[0].id}>{label}</label>}\n            <FormItem formProps={formPropsArr[0]} />\n            <ErrorMessage index={0} />\n         </>\n      );\n   }\n\n   if (layoutType === \"flex\") {\n      return (\n         <>\n            {label && <label htmlFor={formPropsArr[0].id}>{label}</label>}\n            <ul>\n               <li>\n                  <FormItem formProps={formPropsArr[0]} />\n                  <ErrorMessage index={0} />\n               </li>\n               <li>\n                  <FormItem formProps={formPropsArr[1]} />\n                  <ErrorMessage index={1} />\n               </li>\n            </ul>\n         </>\n      );\n   }\n\n   if (layoutType === \"radio-check\") {\n      const Options = formPropsArr.map(\n         ({ id, value, style, optionLabel, ...rest }) => {\n            return (\n               <li key={id}>\n                  <FormItem\n                     formProps={{\n                        id,\n                        value,\n                        style: {\n                           ...RADIO_CHECKBOX_STYLE,\n                           ...(style || {}),\n                        },\n                        ...rest,\n                     }}\n                  />\n                  <label htmlFor={id}>{optionLabel || value}</label>\n               </li>\n            );\n         }\n      );\n      return (\n         <>\n            {label && <label>{label}</label>}\n            <ul>{Options}</ul>\n            <ErrorMessage index={0} />\n         </>\n      );\n   }\n};\n","import { TextareaProps } from \"../..\";\n\nexport const Textarea = ({ formProps }: { formProps: TextareaProps }) => {\n   const { isTextarea, ...rest } = formProps;\n   if (!isTextarea) {\n      return;\n   }\n   return <textarea {...rest} {...isTextarea}></textarea>;\n};\n","import { Input } from \"./components/item/Input\";\nimport { Select } from \"./components/item/Select\";\nimport { FieldLayout } from \"./components/FieldLayout\";\nimport { Textarea } from \"./components/item/Textarea\";\n\ntype SelectOptions = {\n   defaultValue?: string;\n   defaultSelectedIndex?: number;\n   options: string[];\n};\n\nexport type SelectProps = {\n   isSelect?: SelectOptions;\n} & React.SelectHTMLAttributes<HTMLSelectElement>;\n\nexport type TextareaProps = {\n   isTextarea?: React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n} & React.TextareaHTMLAttributes<HTMLTextAreaElement>;\n\ntype OptionLabel = {\n   optionLabel?: React.ReactNode;\n};\n\nexport type FormProps = React.InputHTMLAttributes<HTMLInputElement> &\n   SelectProps &\n   TextareaProps &\n   OptionLabel;\n\nexport type FormFieldsProps = {\n   label?: string | React.ReactNode;\n   /**  param formProps If you set two in an array, they will be arranged as flex. For select and textarea, set tag attributes to isSelect and isTextarea, respectively. */\n   formProps: FormProps[] | FormProps;\n   /** React.ReactNode[] for validation */\n   errors?: React.ReactNode[] | React.ReactNode;\n} & React.FieldsetHTMLAttributes<HTMLFieldSetElement>;\n\n/**\n *\n * ```jsx\n * <FormField\n\t\tclassName={s.field}\n\t\tlabel=\"Mail\"\n\t\tformProps={{\n\t\t\ttype: \"email\",\n\t\t\tid: \"e-mail\",\n\t\t\tplaceholder: \"t.hashimoto@funtech.inc\",\n\t\t\t...register(\"email\", {\n\t\t\t\trequired: VALIDATION.required,\n\t\t\t\tpattern: {\n\t\t\t\t\tvalue: VALIDATION.emailRegExp,\n\t\t\t\t\tmessage: VALIDATION.email,\n\t\t\t\t},\n\t\t\t}),\n\t\t}}\n\t\terrors={<Error error={errors?.email?.message || \"\"} />}\n\t/>\n```\n */\nexport const FormField = ({\n   label,\n   formProps,\n   errors,\n   ...rest\n}: FormFieldsProps) => {\n   if (errors && Array.isArray(errors) && errors.length > 2) {\n      throw new Error(\"The length of error is up to 2.\");\n   }\n\n   const formPropsArr = Array.isArray(formProps) ? formProps : [formProps];\n\n   const { type, isSelect, isTextarea } = formPropsArr[0];\n   const propsLength = formPropsArr.length;\n\n   if (!(type === \"radio\" || type === \"checkbox\") && propsLength > 2) {\n      throw new Error(\"The length of formProps is up to 2.\");\n   }\n\n   const layoutType = [\"radio\", \"checkbox\"].includes(type || \"\")\n      ? \"radio-check\"\n      : propsLength === 1\n      ? \"block\"\n      : \"flex\";\n\n   return (\n      <fieldset {...rest}>\n         <FieldLayout\n            layoutType={layoutType}\n            formPropsArr={formPropsArr}\n            label={label}\n            errors={errors}\n            FormItem={isSelect ? Select : isTextarea ? Textarea : Input}\n         />\n      </fieldset>\n   );\n};\n","import { useMemo } from \"react\";\n\ntype CustomBreakLineParserProps = {\n   children: string;\n};\n\nexport const CustomBreakLineUtils = {\n   regex: /(\\n|###br\\.[^#]+###|###br###)/,\n   isRegularBreak: (line: string) => line === \"\\n\" || line === \"###br###\",\n   isSpecificBreak: (line: string) => line.match(/###br\\.(.*?)###/),\n   getClassName: (line: string) =>\n      line.match(/(?<=###br\\.).+?(?=###)/)?.[0] || \"\",\n};\n\n/**\n * @returns {(string | JSX.Element)[]} - A React fragment containing the formatted string with line breaks represented as `<br>` elements.\n */\nconst useParsedBreakLine = (string: string): (string | JSX.Element)[] =>\n   useMemo(\n      () =>\n         string.split(CustomBreakLineUtils.regex).map((line, index) => {\n            // \\n or ###br### is a regular line break\n            if (CustomBreakLineUtils.isRegularBreak(line)) {\n               return <br key={index} />;\n            }\n            // ###br.className### is a line break with a specified class name\n            if (CustomBreakLineUtils.isSpecificBreak(line)) {\n               return (\n                  <br\n                     className={CustomBreakLineUtils.getClassName(line)}\n                     key={index}\n                  />\n               );\n            }\n            // Regular text\n            return line;\n         }),\n      [string]\n   );\n\n/**\n * Converts specific markers in a string into HTML line breaks for React components.\n * @param {string} children - The input string to be parsed and formatted. Use `\\n` or `###br###` for regular line breaks, and `###br.className###` for a line break with a specific class.\n * @returns {React.ReactElement} - The formatted string\n */\nconst CustomBreakLineParser = ({\n   children,\n}: CustomBreakLineParserProps): React.ReactElement => {\n   const parsedText = useParsedBreakLine(children);\n   return <>{parsedText}</>;\n};\n\nexport { useParsedBreakLine, CustomBreakLineParser };\n","import { useMemo } from \"react\";\nimport { CustomBreakLineUtils } from \"../CustomBreakLineParser\";\n\ntype SpanOmittedChildren = Omit<\n   React.HTMLAttributes<HTMLSpanElement>,\n   \"children\"\n>;\n\nexport type SplitTextProps = {\n   /** Split by character or by word . For `words`, split by whitespace. */\n   type?: \"chars\" | \"words\";\n   /** It is possible to set exceptional attributes for certain characters only */\n   exception?: {\n      selector: string;\n      attributes?: SpanOmittedChildren;\n   }[];\n   containerProps?: SpanOmittedChildren;\n   children: string;\n} & SpanOmittedChildren;\n\nconst SplitContainer = ({\n   containerProps,\n   ...props\n}: {\n   containerProps?: SpanOmittedChildren;\n} & React.HTMLAttributes<HTMLSpanElement>) => {\n   if (containerProps) {\n      return (\n         <span {...containerProps}>\n            <span {...props} />\n         </span>\n      );\n   }\n   return <span {...props} />;\n};\n\n/**\n * @param children - The input string to be parsed and formatted. Use `\\n` or `###br###` for regular line breaks, and `###br.className###` for a line break with a specific class.\n */\nexport const SplitText = ({\n   type = \"chars\",\n   children,\n   exception,\n   containerProps,\n   ...rest\n}: SplitTextProps) => {\n   const splitTag = type === \"chars\" ? \"\" : \" \";\n\n   const wrappedText = useMemo(\n      () =>\n         children.split(CustomBreakLineUtils.regex).flatMap((line, i) => {\n            if (CustomBreakLineUtils.isRegularBreak(line)) {\n               return [null, <br key={i} />];\n            }\n            if (CustomBreakLineUtils.isSpecificBreak(line)) {\n               return [\n                  null,\n                  <br\n                     key={i}\n                     className={CustomBreakLineUtils.getClassName(line)}\n                  />,\n               ];\n            }\n            return [\n               ...line.split(splitTag).map((char, charI) => {\n                  if (exception) {\n                     const match = exception.find(\n                        (item) => item.selector === char\n                     );\n                     if (match) {\n                        return (\n                           <SplitContainer\n                              key={`${i}-${charI}`}\n                              containerProps={containerProps}\n                              {...rest}\n                              {...match.attributes}>\n                              {char}\n                           </SplitContainer>\n                        );\n                     }\n                  }\n                  return (\n                     <SplitContainer\n                        key={`${i}-${charI}`}\n                        containerProps={containerProps}\n                        {...rest}>\n                        {char === \" \" ? \"\\u00A0\" : char}\n                     </SplitContainer>\n                  );\n               }),\n               null,\n            ];\n         }),\n      [splitTag, children, rest, exception, containerProps]\n   );\n\n   return wrappedText;\n};\n","import { VideoHTMLAttributes, forwardRef } from \"react\";\n\nexport interface VideoProps extends VideoHTMLAttributes<HTMLVideoElement> {\n   fill?: boolean;\n}\n\nexport const Video = forwardRef<HTMLVideoElement, VideoProps>((props, ref) => {\n   const { fill, style, ...rest } = props;\n   return (\n      <video\n         ref={ref}\n         style={\n            fill\n               ? {\n                    ...{\n                       position: \"absolute\",\n                       width: \"100%\",\n                       height: \"100%\",\n                       inset: 0,\n                       color: \"transparent\",\n                    },\n                    ...style,\n                 }\n               : style\n         }\n         {...rest}></video>\n   );\n});\n\nVideo.displayName = \"Video\";\n"],"names":["Input","formProps","style","rest","jsx","Select","isSelect","DefaultValue","defaultValue","getSelectedIndex","i","jsxs","option","RADIO_CHECKBOX_STYLE","FieldLayout","layoutType","formPropsArr","label","FormItem","errors","ErrorMessage","index","Fragment","Options","id","value","optionLabel","Textarea","isTextarea","FormField","type","propsLength","CustomBreakLineUtils","line","_a","useParsedBreakLine","string","useMemo","CustomBreakLineParser","children","parsedText","SplitContainer","containerProps","props","SplitText","exception","splitTag","char","charI","match","item","Video","forwardRef","ref","fill"],"mappings":"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"}